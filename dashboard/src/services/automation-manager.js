/**
 * Automation Manager Service
 * 
 * Handles creating, updating, and removing Home Assistant automations
 * for phenology-based environment control.
 */

import { ENTITIES } from '../types/entities';

/**
 * Automation ID constants
 * Using consistent naming for easy identification
 */
export const AUTOMATION_IDS = {
  LIGHT_ON: 'phenology_light_on',
  LIGHT_OFF: 'phenology_light_off',
  TEMP_DAY: 'phenology_temp_day',
  TEMP_NIGHT: 'phenology_temp_night',
  VPD_HUMID_ON: 'phenology_vpd_humidifier_on',
  VPD_HUMID_OFF: 'phenology_vpd_humidifier_off',
  VPD_FAN_REDUCE: 'phenology_vpd_fan_reduce',
  VPD_FAN_RESTORE: 'phenology_vpd_fan_restore',
};

/**
 * IDs of existing user automations that may conflict
 */
const CONFLICTING_AUTOMATIONS = [
  'automation.grow_light_control',
  'automation.tent_temperature_modulation',
];

/**
 * Automation IDs that conflict with the dashboard controller ("brain")
 * These should be skipped when the dashboard controller is active
 * to prevent rate limit conflicts with AC Infinity API
 * 
 * The dashboard controller intelligently handles:
 * - Humidifier On/Off and intensity control
 * - Exhaust fan power adjustments
 * - Coordinated VPD management
 * 
 * These HA automations are simple threshold-based and would conflict.
 */
export const CONTROLLER_CONFLICTING_AUTOMATIONS = [
  AUTOMATION_IDS.VPD_HUMID_ON,      // Controller handles humidifier On/Off
  AUTOMATION_IDS.VPD_HUMID_OFF,     // Controller handles humidifier On/Off
  AUTOMATION_IDS.VPD_FAN_REDUCE,    // Controller handles fan power
  AUTOMATION_IDS.VPD_FAN_RESTORE,   // Controller handles fan power
  // Note: TEMP_DAY/NIGHT can coexist (heater isn't AC Infinity, less rate limiting)
  // but consider disabling if conflicts occur
];

/**
 * Build automation config for lights ON
 * @param {Object} stage - Growth stage object
 * @returns {Object} Automation config
 */
export function buildLightOnAutomation(stage) {
  // Special case: harvest/dry stage keeps lights off
  if (stage.id === 'harvest_dry') {
    return null;
  }

  // Ensure we have a valid lightSchedule
  if (!stage.lightSchedule || !stage.lightSchedule.onTime) {
    console.error('[AUTO-MGR] buildLightOnAutomation: Missing lightSchedule.onTime', stage);
    return null;
  }

  const onTime = stage.lightSchedule.onTime;
  console.log(`[AUTO-MGR] buildLightOnAutomation: Using onTime=${onTime} for stage ${stage.name}`);
  
  return {
    id: AUTOMATION_IDS.LIGHT_ON,
    alias: `Phenology: Lights ON (${stage.name})`,
    description: `Turn on grow light at ${onTime} for ${stage.name} stage. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'time',
        at: onTime + ':00',
      },
    ],
    condition: [],
    action: [
      {
        service: 'switch.turn_on',
        target: {
          entity_id: ENTITIES.LIGHT,
        },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation config for lights OFF
 * @param {Object} stage - Growth stage object
 * @returns {Object} Automation config
 */
export function buildLightOffAutomation(stage) {
  // Special case: harvest/dry stage - ensure lights stay off
  if (stage.id === 'harvest_dry') {
    return {
      id: AUTOMATION_IDS.LIGHT_OFF,
      alias: `Phenology: Lights OFF (${stage.name})`,
      description: `Keep lights off during ${stage.name} stage. Auto-generated by GrowOp Dashboard.`,
      trigger: [
        {
          platform: 'time',
          at: '00:00:00', // Run once daily at midnight
        },
      ],
      condition: [],
      action: [
        {
          service: 'switch.turn_off',
          target: {
            entity_id: ENTITIES.LIGHT,
          },
        },
      ],
      mode: 'single',
    };
  }

  // Ensure we have a valid lightSchedule
  if (!stage.lightSchedule || !stage.lightSchedule.offTime) {
    console.error('[AUTO-MGR] buildLightOffAutomation: Missing lightSchedule.offTime', stage);
    return null;
  }

  const offTime = stage.lightSchedule.offTime;
  console.log(`[AUTO-MGR] buildLightOffAutomation: Using offTime=${offTime} for stage ${stage.name}`);
  
  return {
    id: AUTOMATION_IDS.LIGHT_OFF,
    alias: `Phenology: Lights OFF (${stage.name})`,
    description: `Turn off grow light at ${offTime} for ${stage.name} stage. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'time',
        at: offTime + ':00',
      },
    ],
    condition: [],
    action: [
      {
        service: 'switch.turn_off',
        target: {
          entity_id: ENTITIES.LIGHT,
        },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation config for day temperature
 * @param {Object} stage - Growth stage object
 * @returns {Object} Automation config
 */
export function buildDayTempAutomation(stage) {
  return {
    id: AUTOMATION_IDS.TEMP_DAY,
    alias: `Phenology: Day Temp (${stage.name})`,
    description: `Set heater to ${stage.temperature.day.target}°F at lights on. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'time',
        at: stage.lightSchedule.onTime + ':00',
      },
    ],
    condition: [],
    action: [
      {
        service: 'climate.set_temperature',
        target: {
          entity_id: ENTITIES.HEATER,
        },
        data: {
          temperature: stage.temperature.day.target,
          hvac_mode: 'heat',
        },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation config for night temperature
 * @param {Object} stage - Growth stage object
 * @returns {Object} Automation config
 */
export function buildNightTempAutomation(stage) {
  return {
    id: AUTOMATION_IDS.TEMP_NIGHT,
    alias: `Phenology: Night Temp (${stage.name})`,
    description: `Set heater to ${stage.temperature.night.target}°F at lights off. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'time',
        at: stage.lightSchedule.offTime + ':00',
      },
    ],
    condition: [],
    action: [
      {
        service: 'climate.set_temperature',
        target: {
          entity_id: ENTITIES.HEATER,
        },
        data: {
          temperature: stage.temperature.night.target,
          hvac_mode: 'heat',
        },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation config for VPD-based humidifier ON
 * @param {Object} stage - Growth stage object
 * @returns {Object} Automation config
 */
export function buildVPDHumidifierOnAutomation(stage) {
  // Skip for harvest/dry stage (VPD control not applicable)
  if (stage.id === 'harvest_dry') {
    return null;
  }

  return {
    id: AUTOMATION_IDS.VPD_HUMID_ON,
    alias: `Phenology: VPD High - Humidifier ON (${stage.name})`,
    description: `Turn on CloudForge T5 when VPD > ${stage.vpd.max} kPa. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'numeric_state',
        entity_id: ENTITIES.VPD,
        above: stage.vpd.max,
        for: {
          minutes: 5,
        },
      },
    ],
    condition: [
      {
        condition: 'state',
        entity_id: ENTITIES.LIGHT,
        state: 'on', // Only humidify during day period
      },
    ],
    action: [
      {
        service: 'select.select_option',
        target: {
          entity_id: ENTITIES.HUMIDIFIER_MODE,
        },
        data: {
          option: 'On',
        },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation config for VPD-based humidifier OFF
 * @param {Object} stage - Growth stage object
 * @returns {Object} Automation config
 */
export function buildVPDHumidifierOffAutomation(stage) {
  // Skip for harvest/dry stage
  if (stage.id === 'harvest_dry') {
    return null;
  }

  return {
    id: AUTOMATION_IDS.VPD_HUMID_OFF,
    alias: `Phenology: VPD OK - Humidifier OFF (${stage.name})`,
    description: `Turn off CloudForge T5 when VPD < ${stage.vpd.optimal} kPa. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'numeric_state',
        entity_id: ENTITIES.VPD,
        below: stage.vpd.optimal,
        for: {
          minutes: 10, // Longer delay to prevent rapid cycling
        },
      },
    ],
    condition: [],
    action: [
      {
        service: 'select.select_option',
        target: {
          entity_id: ENTITIES.HUMIDIFIER_MODE,
        },
        data: {
          option: 'Off',
        },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation: Reduce exhaust fan power when VPD is too high
 * 
 * Strategy: When VPD exceeds target, the humidifier is working against
 * the exhaust fan. By reducing fan power, we retain more moisture in
 * the tent, allowing the humidifier to catch up.
 * 
 * @param {Object} stage - Growth stage object from phenology
 * @returns {Object|null} Automation config or null if not applicable
 */
export function buildVPDFanReduceAutomation(stage) {
  // Skip for harvest stage (no active plants to transpire)
  if (stage.id === 'harvest_dry') return null;

  const reducedPower = 2; // Low power (1-10 scale)
  
  return {
    id: AUTOMATION_IDS.VPD_FAN_REDUCE,
    alias: `Phenology: VPD High - Reduce Exhaust Fan (${stage.name})`,
    description: `Reduce exhaust fan power to ${reducedPower} when VPD > ${stage.vpd.max} kPa to help humidifier catch up. This retains moisture in the tent while the humidifier works to increase humidity. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'numeric_state',
        entity_id: ENTITIES.VPD,
        above: stage.vpd.max, // Stage-specific (0.8 for seedling)
        for: { minutes: 5 }, // Prevent rapid cycling
      },
    ],
    condition: [
      {
        condition: 'state',
        entity_id: ENTITIES.LIGHT,
        state: 'on', // Only during day period (active transpiration)
      },
      {
        condition: 'state',
        entity_id: ENTITIES.EXHAUST_FAN_MODE,
        state: ['On', 'Auto'], // Fan must be On or Auto (not Off) for power control to work
      },
      {
        condition: 'numeric_state',
        entity_id: ENTITIES.EXHAUST_FAN_CURRENT_POWER,  // ✅ Verified exists (sensor, read-only)
        above: reducedPower, // Only reduce if currently higher
      },
    ],
    action: [
      {
        service: 'number.set_value',
        target: { entity_id: ENTITIES.EXHAUST_FAN_ON_POWER },
        data: { value: reducedPower },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build automation: Restore exhaust fan power when VPD is optimal
 * 
 * Strategy: Once VPD drops below the optimal threshold, we can safely
 * restore the fan to normal power without fighting the humidifier.
 * Longer delay ensures VPD has stabilized before restoring.
 * 
 * @param {Object} stage - Growth stage object from phenology
 * @returns {Object|null} Automation config or null if not applicable
 */
export function buildVPDFanRestoreAutomation(stage) {
  // Skip for harvest stage
  if (stage.id === 'harvest_dry') return null;

  const normalPower = 5; // Normal power level
  
  return {
    id: AUTOMATION_IDS.VPD_FAN_RESTORE,
    alias: `Phenology: VPD OK - Restore Exhaust Fan (${stage.name})`,
    description: `Restore exhaust fan power to ${normalPower} when VPD < ${stage.vpd.optimal} kPa. Longer delay ensures VPD has stabilized. Auto-generated by GrowOp Dashboard.`,
    trigger: [
      {
        platform: 'numeric_state',
        entity_id: ENTITIES.VPD,
        below: stage.vpd.optimal, // Stage-specific (0.6 for seedling)
        for: { minutes: 10 }, // Longer delay to ensure stability
      },
    ],
    condition: [
      {
        condition: 'numeric_state',
        entity_id: ENTITIES.EXHAUST_FAN_CURRENT_POWER,
        below: normalPower, // Only restore if currently lower
      },
    ],
    action: [
      {
        service: 'number.set_value',
        target: { entity_id: ENTITIES.EXHAUST_FAN_ON_POWER },
        data: { value: normalPower },
      },
    ],
    mode: 'single',
  };
}

/**
 * Build all automation configs for a stage
 * 
 * By default, skips automations that conflict with the dashboard controller ("brain").
 * The brain handles: humidifier On/Off, exhaust fan power, and coordinated VPD control.
 * 
 * @param {Object} stage - Growth stage object
 * @param {Object} options - Options for building automations
 * @param {boolean} options.skipControllerConflicts - Skip automations that conflict with dashboard controller (default: true)
 * @returns {Object[]} Array of automation configs
 */
export function buildAllAutomations(stage, options = {}) {
  const { skipControllerConflicts = true } = options;
  
  const allAutomations = [
    buildLightOnAutomation(stage),
    buildLightOffAutomation(stage),
    buildDayTempAutomation(stage),
    buildNightTempAutomation(stage),
    buildVPDHumidifierOnAutomation(stage),
    buildVPDHumidifierOffAutomation(stage),
    buildVPDFanReduceAutomation(stage),
    buildVPDFanRestoreAutomation(stage),
  ];

  // Filter out nulls (harvest_dry skips some automations)
  let automations = allAutomations.filter(Boolean);
  
  // Skip automations that conflict with dashboard controller
  if (skipControllerConflicts) {
    const beforeCount = automations.length;
    automations = automations.filter(automation => 
      !CONTROLLER_CONFLICTING_AUTOMATIONS.includes(automation.id)
    );
    const skippedCount = beforeCount - automations.length;
    if (skippedCount > 0) {
      console.log(`[AUTO-MGR] Skipped ${skippedCount} automations that conflict with dashboard controller`);
      console.log(`[AUTO-MGR] Skipped IDs:`, CONTROLLER_CONFLICTING_AUTOMATIONS.filter(id => 
        allAutomations.some(a => a && a.id === id)
      ));
      console.log(`[AUTO-MGR] Dashboard brain handles: humidifier On/Off, exhaust fan power, VPD coordination`);
    }
  }
  
  return automations;
}

/**
 * Generate YAML representation of an automation
 * For manual copy-paste if API fails
 * @param {Object} config - Automation config object
 * @returns {string} YAML string
 */
export function automationToYAML(config) {
  // Simple YAML generator (not using a library to keep deps minimal)
  const indent = (str, level = 0) => '  '.repeat(level) + str;
  const lines = [];

  lines.push(`- id: "${config.id}"`);
  lines.push(`  alias: "${config.alias}"`);
  lines.push(`  description: "${config.description}"`);
  lines.push(`  mode: ${config.mode}`);
  
  // Trigger
  lines.push(`  trigger:`);
  config.trigger.forEach(t => {
    lines.push(`    - platform: ${t.platform}`);
    if (t.at) lines.push(`      at: "${t.at}"`);
    if (t.entity_id) lines.push(`      entity_id: ${t.entity_id}`);
    if (t.above !== undefined) lines.push(`      above: ${t.above}`);
    if (t.below !== undefined) lines.push(`      below: ${t.below}`);
    if (t.for) {
      lines.push(`      for:`);
      if (t.for.minutes) lines.push(`        minutes: ${t.for.minutes}`);
    }
  });

  // Condition
  lines.push(`  condition:`);
  if (config.condition.length === 0) {
    lines.push(`    []`);
  } else {
    config.condition.forEach(c => {
      lines.push(`    - condition: ${c.condition}`);
      if (c.entity_id) lines.push(`      entity_id: ${c.entity_id}`);
      if (c.state) {
        // Handle both string and array states
        if (Array.isArray(c.state)) {
          lines.push(`      state:`);
          c.state.forEach(s => lines.push(`        - "${s}"`));
        } else {
          lines.push(`      state: "${c.state}"`);
        }
      }
    });
  }

  // Action
  lines.push(`  action:`);
  config.action.forEach(a => {
    lines.push(`    - service: ${a.service}`);
    if (a.target) {
      lines.push(`      target:`);
      lines.push(`        entity_id: ${a.target.entity_id}`);
    }
    if (a.data) {
      lines.push(`      data:`);
      Object.entries(a.data).forEach(([key, value]) => {
        if (typeof value === 'string') {
          lines.push(`        ${key}: "${value}"`);
        } else {
          lines.push(`        ${key}: ${value}`);
        }
      });
    }
  });

  return lines.join('\n');
}

/**
 * Generate YAML for all automations
 * @param {Object} stage - Growth stage object
 * @returns {string} Complete YAML for all automations
 */
/**
 * Generate YAML for all automations (for manual deployment if needed)
 * @param {Object} stage - Growth stage object
 * @param {Object} options - Options (same as buildAllAutomations)
 * @returns {string} Complete YAML for all automations
 */
export function generateAllYAML(stage, options = {}) {
  const automations = buildAllAutomations(stage, options);
  return automations.map(automationToYAML).join('\n\n');
}

/**
 * Deploy automations to Home Assistant
 * 
 * @param {Object} stage - Growth stage object
 * @param {Object} options - Deployment options
 * @param {boolean} options.dryRun - If true, only return configs without deploying
 * @param {Function} options.createAutomation - Function to create/update automation in HA
 * @param {Function} options.reloadAutomations - Function to reload automations in HA
 * @param {Function} options.disableAutomation - Function to disable an automation
 * @returns {Promise<Object>} Deployment result
 */
/**
 * Deploy automations to Home Assistant
 * 
 * @param {Object} stage - Growth stage object
 * @param {Object} options - Deployment options
 * @param {Function} options.createAutomation - Function to create/update automation in HA
 * @param {Function} options.reloadAutomations - Function to reload automations in HA
 * @param {Function} options.disableAutomation - Function to disable an automation
 * @param {boolean} options.skipControllerConflicts - Skip automations that conflict with dashboard controller (default: true)
 */
export async function deployStageAutomations(stage, options = {}) {
  const {
    dryRun = false,
    createAutomation,
    reloadAutomations,
    disableAutomation,
  } = options;

  const { skipControllerConflicts = true } = options;
  
  console.log(`[AUTO-MGR] Building automations for stage: ${stage.name}`);
  if (skipControllerConflicts) {
    console.log(`[AUTO-MGR] Skipping automations that conflict with dashboard controller`);
  }
  console.log(`[AUTO-MGR] Stage data:`, {
    lightSchedule: stage.lightSchedule,
    temperature: stage.temperature,
    vpd: stage.vpd,
  });
  
  const configs = buildAllAutomations(stage, { skipControllerConflicts });
  console.log(`[AUTO-MGR] Built ${configs.length} automation configs:`, configs.map(c => c.id));
  
  if (dryRun) {
    console.log('[AUTO-MGR] Dry run - returning configs without deploying');
    return {
      success: true,
      deployed: [],
      failed: [],
      configs,
      yaml: generateAllYAML(stage),
    };
  }

  // Verify we have the required functions
  if (!createAutomation || !reloadAutomations) {
    console.error('[AUTO-MGR] Missing required API functions');
    return {
      success: false,
      deployed: [],
      failed: configs.map(c => ({ id: c.id, error: 'Missing API functions' })),
      configs,
      yaml: generateAllYAML(stage),
    };
  }

  const deployed = [];
  const failed = [];

  // Disable conflicting automations first
  if (disableAutomation) {
    console.log('[AUTO-MGR] Disabling conflicting automations...');
    for (const automationId of CONFLICTING_AUTOMATIONS) {
      try {
        await disableAutomation(automationId);
        console.log(`[AUTO-MGR] Disabled: ${automationId}`);
      } catch (err) {
        console.warn(`[AUTO-MGR] Could not disable ${automationId}:`, err.message);
        // Non-fatal - continue with deployment
      }
    }
  }

  // Deploy each automation
  console.log(`[AUTO-MGR] Starting deployment of ${configs.length} automations...`);
  for (const config of configs) {
    try {
      console.log(`[AUTO-MGR] Deploying: ${config.alias} (${config.id})`);
      console.log(`[AUTO-MGR] Config:`, JSON.stringify(config, null, 2));
      const result = await createAutomation(config.id, config);
      console.log(`[AUTO-MGR] Deployment result for ${config.id}:`, result);
      if (result && !result.success) {
        throw new Error(result.error || 'Unknown error');
      }
      deployed.push({ id: config.id, alias: config.alias });
      console.log(`[AUTO-MGR] Successfully deployed: ${config.id}`);
    } catch (err) {
      console.error(`[AUTO-MGR] Failed to deploy ${config.id}:`, err);
      failed.push({ id: config.id, alias: config.alias, error: err.message || String(err) });
    }
  }

  // Reload automations in HA (non-blocking - continue even if it fails)
  try {
    console.log('[AUTO-MGR] Reloading automations in HA...');
    const reloadResult = await reloadAutomations();
    if (!reloadResult.success) {
      console.warn('[AUTO-MGR] Reload failed but continuing:', reloadResult.error);
      console.warn('[AUTO-MGR] Note: You may need to manually reload automations in HA for changes to take effect');
    } else {
      // Wait a moment for HA to process
      await new Promise(resolve => setTimeout(resolve, 2000));
      console.log('[AUTO-MGR] Automations reloaded successfully');
    }
  } catch (err) {
    console.warn('[AUTO-MGR] Failed to reload automations (non-fatal):', err.message);
    console.warn('[AUTO-MGR] Note: You may need to manually reload automations in HA for changes to take effect');
  }

  const success = failed.length === 0;
  console.log(`[AUTO-MGR] Deployment complete. Success: ${deployed.length}, Failed: ${failed.length}`);

  return {
    success,
    deployed,
    failed,
    configs,
    yaml: generateAllYAML(stage),
    timestamp: new Date().toISOString(),
  };
}

/**
 * Remove all phenology automations
 * @param {Function} deleteAutomation - Function to delete automation
 * @returns {Promise<Object>} Removal result
 */
export async function removeStageAutomations(deleteAutomation) {
  const automationIds = Object.values(AUTOMATION_IDS);
  const removed = [];
  const failed = [];

  for (const id of automationIds) {
    try {
      await deleteAutomation(id);
      removed.push(id);
    } catch (err) {
      // Ignore 404 errors (automation doesn't exist)
      if (!err.message?.includes('404')) {
        failed.push({ id, error: err.message });
      }
    }
  }

  return { removed, failed };
}

/**
 * Check which phenology automations currently exist
 * @param {Function} getAutomation - Function to get automation
 * @returns {Promise<string[]>} List of existing automation IDs
 */
export async function getDeployedAutomations(getAutomation) {
  const automationIds = Object.values(AUTOMATION_IDS);
  const existing = [];

  for (const id of automationIds) {
    try {
      await getAutomation(`automation.${id}`);
      existing.push(id);
    } catch (err) {
      // Automation doesn't exist
    }
  }

  return existing;
}
